"use strict";

import { first, last, getClosestItemIndexes, isNotDefined, getLogger } from "../utils";

var log = getLogger("evaluator");

function extentsWrapper(xAccessor, useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold) {
	function domain(data, inputDomain, xAccessor, initialXScale, currentPlotData, currentDomain) {
		if (useWholeData) {
			return { plotData: data, domain: inputDomain };
		}

		var left = first(inputDomain);
		var right = last(inputDomain);

		var filteredData = getFilteredResponse(data, left, right, xAccessor);
		var clampedDomain = [Math.max(left, xAccessor(first(data))), Math.min(right, xAccessor(last(data)))];

		var realInputDomain = xAccessor === xAccessor ? clamp ? clampedDomain : inputDomain : [xAccessor(first(filteredData)), xAccessor(last(filteredData))];

		var xScale = initialXScale.copy().domain(realInputDomain);

		var width = Math.floor(xScale(xAccessor(last(filteredData))) - xScale(xAccessor(first(filteredData))));

		var plotData = void 0,
		    domain = void 0;

		var chartWidth = last(xScale.range()) - first(xScale.range());

		log("Trying to show " + filteredData.length + " in " + width + "px," + (" I can show up to " + showMax(width, pointsPerPxThreshold) + " in that width. ") + ("Also FYI the entire chart width is " + chartWidth + "px and pointsPerPxThreshold is " + pointsPerPxThreshold));

		if (canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {
			plotData = filteredData;
			domain = realInputDomain;
			log("AND IT WORKED");
		} else {
			plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));
			domain = currentDomain || [xAccessor(first(plotData)), xAccessor(last(plotData))];

			var newXScale = xScale.copy().domain(domain);
			var newWidth = Math.floor(newXScale(xAccessor(last(plotData))) - newXScale(xAccessor(first(plotData))));

			log("and ouch, that is too much, so instead showing " + plotData.length + " in " + newWidth + "px");
		}

		return { plotData: plotData, domain: domain };
	}
	return domain;
}

function canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {
	return arrayLength > showMinThreshold(width, minThreshold) && arrayLength < showMaxThreshold(width, maxThreshold);
}

function showMinThreshold(width, threshold) {
	return Math.max(1, Math.ceil(width * threshold));
}

function showMaxThreshold(width, threshold) {
	return Math.floor(width * threshold);
}

function showMax(width, threshold) {
	return Math.floor(showMaxThreshold(width, threshold) * 0.97);
}

function getFilteredResponse(data, left, right, xAccessor) {
	var newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;
	var newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;

	var filteredData = data.slice(newLeftIndex, newRightIndex + 1);
	// console.log(right, newRightIndex, dataForInterval.length);

	return filteredData;
}

export default function (_ref) {
	var xAccessor = _ref.xAccessor,
	    xScale = _ref.xScale,
	    useWholeData = _ref.useWholeData,
	    clamp = _ref.clamp,
	    pointsPerPxThreshold = _ref.pointsPerPxThreshold,
	    minPointsPerPxThreshold = _ref.minPointsPerPxThreshold;

	return extentsWrapper(xAccessor, useWholeData || isNotDefined(xScale.invert), clamp, pointsPerPxThreshold, minPointsPerPxThreshold);
}
//# sourceMappingURL=evaluator.js.map